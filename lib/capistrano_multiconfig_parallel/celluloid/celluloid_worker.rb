require_relative './child_process'
require_relative './state_machine'
module CapistranoMulticonfigParallel
  # rubocop:disable ClassLength
  # worker that will spawn a child process in order to execute a capistrano job and monitor that process
  #
  # @!attribute job
  #   @return [Hash] options used for executing capistrano task
  #   @option options [String] :id The id of the job ( will ge automatically generated by CapistranoMulticonfigParallel::CelluloidManager when delegating job)
  #   @option options [String] :app The application name that will be deployed
  #   @option options [String] :env The stage used for that application
  #   @option options [String] :action The action that this action will be doing (deploy, or other task)
  #   @option options [Hash] :env_options  options that are available  in the environment variable ENV when this task is going to be executed
  #   @option options [Array] :task_arguments arguments to the task
  #
  # @!attribute manager
  #   @return [CapistranoMulticonfigParallel::CelluloidManager] the instance of the manager that delegated the job to this worker
  #
  class CelluloidWorker
    include Celluloid
    include Celluloid::Notifications
    include Celluloid::Logger
    class TaskFailed < StandardError; end

    attr_accessor :job, :manager, :job_id, :app_name, :env_name, :action_name, :env_options, :machine, :client, :task_argv, :execute_deploy, :executed_dry_run,
                  :rake_tasks, :current_task_number, # tracking tasks
                  :successfull_subscription, :subscription_channel, :publisher_channel, # for subscriptions and publishing events
                  :task_confirmations, :manager_condition, :last_manager_condition # for task conifirmations from manager

    def work(job, manager)
      @job = job
      @manager = manager

      process_job(job) if job.present?
      debug("worker #{@job_id} received #{job.inspect}") if debug_enabled?
      @subscription_channel = "worker_#{@job_id}"
      @machine = CapistranoMulticonfigParallel::StateMachine.new(job, Actor.current)
      setup_worker_condition
      manager.register_worker_for_job(job, Actor.current)
    end

    def debug_enabled?
      @manager.class.debug_enabled?
    end

    def start_task
      debug("exec worker #{@job_id} starts task with #{@job.inspect}") if debug_enabled?
      @task_confirmations = CapistranoMulticonfigParallel.configuration.task_confirmations
      @client = CelluloidPubsub::Client.connect(actor: Actor.current, enable_debug: @manager.class.debug_websocket?) do |ws|
        ws.subscribe(@subscription_channel)
      end
    end

    def publish_rake_event(data)
      @client.publish(rake_actor_id(data), data)
    end

    def rake_actor_id(data)
      data['action'].present? && data['action'] == 'count' ? "rake_worker_#{@job_id}_count" : "rake_worker_#{@job_id}"
    end

    def on_message(message)
      debug("worker #{@job_id} received:  #{message.inspect}") if debug_enabled?
      if @client.succesfull_subscription?(message)
        @successfull_subscription = true
        execute_after_succesfull_subscription
      else
        handle_subscription(message)
      end
    end

    def execute_after_succesfull_subscription
      setup_task_arguments
      if (@action_name == 'deploy' || @action_name == 'deploy:rollback') && CapistranoMulticonfigParallel.show_task_progress
        @executed_dry_run = true
        @rake_tasks = []
        @task_argv << '--dry-run'
        @task_argv << 'count_rake=true'
        @child_process = CapistranoMulticonfigParallel::ChildProcess.new
        Actor.current.link @child_process
        debug("worker #{@job_id} executes: bundle exec multi_cap #{@task_argv.join(' ')}") if debug_enabled?
        @child_process.async.work("bundle exec multi_cap #{@task_argv.join(' ')}", actor: Actor.current, dry_run: true)
      else
        async.execute_deploy
      end
    end

    def rake_tasks
      @rake_tasks ||= []
    end

    def execute_deploy
      @execute_deploy = true
      debug("invocation chain #{@job_id} is : #{@rake_tasks.inspect}") if debug_enabled? && CapistranoMulticonfigParallel.show_task_progress
      if !defined?(@child_process) || @child_process.nil?
        @child_process = CapistranoMulticonfigParallel::ChildProcess.new
        Actor.current.link @child_process
      else
        @client.unsubscribe("rake_worker_#{@job_id}_count")
        @child_process.exit_status = nil
      end
      setup_task_arguments
      debug("worker #{@job_id} executes: bundle exec multi_cap #{@task_argv.join(' ')}") if debug_enabled?
      @child_process.async.work("bundle exec multi_cap #{@task_argv.join(' ')}", actor: Actor.current, silent: true)
    end

    def on_close(code, reason)
      debug("worker #{@job_id} websocket connection closed: #{code.inspect}, #{reason.inspect}") if debug_enabled?
    end

    def handle_subscription(message)
      if message_is_about_a_task?(message)
        save_tasks_to_be_executed(message)
        update_machine_state(message['task']) # if message['action'] == 'invoke'
        debug("worker #{@job_id} state is #{@machine.state}") if debug_enabled?
        task_approval(message)
      else
        debug("worker #{@job_id} could not handle  #{message}") if debug_enabled?
      end
    end

    def message_is_about_a_task?(message)
      message.present? && message.is_a?(Hash) && message['action'].present? && message['job_id'].present? && message['task'].present?
    end

    def task_approval(message)
      if @task_confirmations.include?(message['task']) && message['action'] == 'invoke'
        @manager_condition[message['task']].call(message['task'])
      else
        publish_rake_event(message.merge('approved' => 'yes'))
      end
    end

    def save_tasks_to_be_executed(message)
      return unless message['action'] == 'count'
      debug("worler #{@job_id} current invocation chain : #{@rake_tasks.inspect}") if debug_enabled?
      @rake_tasks = [] if @rake_tasks.blank?
      @rake_tasks << message['task'] if @rake_tasks.last != message['task']
    end

    def update_machine_state(name)
      debug("worker #{@job_id} triest to transition from #{@machine.state} to  #{name}") if debug_enabled?
      @machine.transitions.on(name.to_s, @machine.state => name.to_s)
      @machine.go_to_transition(name.to_s)
      raise(CapistranoMulticonfigParallel::CelluloidWorker::TaskFailed, "task #{@action} failed ") if name == 'deploy:failed' # force worker to rollback
    end

    def setup_command_line(*options)
      @task_argv = []
      options.each do |option|
        @task_argv << option
      end
      @task_argv
    end

    def setup_task_arguments
      #   stage = "#{@app_name}:#{@env_name} #{@action_name}"
      stage = @app_name.present? ? "#{@app_name}:#{@env_name}" : "#{@env_name}"
      array_options = ["#{stage}"]
      array_options << "#{@action_name}[#{@task_arguments.join(',')}]"
      @env_options.each do |key, value|
        array_options << "#{key}=#{value}" if value.present?
      end
      array_options << '--trace' if debug_enabled?
      setup_command_line(*array_options)
    end

    def send_msg(channel, message = nil)
      publish channel, message.present? && message.is_a?(Hash) ? { job_id: @job_id }.merge(message) : { job_id: @job_id, time: Time.now }
    end

    def process_job(job)
      @job_id = job['id']
      @app_name = job['app']
      @env_name = job['env']
      @action_name = job['action']
      @env_options = {}
      job['env_options'].each do |key, value|
        @env_options[key] = value if value.present?
      end
      @task_arguments = job['task_arguments']
    end

    def need_confirmation_for_tasks?
      executes_deploy? == true  && @manager.need_confirmations?
    end

    def executes_deploy?
      (@action_name == 'deploy' || @action_name == 'deploy:rollback')
    end

    def setup_worker_condition
      job_termination_condition = Celluloid::Condition.new
      job_confirmation_conditions = []
      CapistranoMulticonfigParallel.configuration.task_confirmations.each do |_task|
        if need_confirmation_for_tasks?
          job_confirmation_conditions << Celluloid::Condition.new
        else
          job_confirmation_conditions << proc { |sum| sum }
        end
      end
      @manager.job_to_condition[@job_id] = { first_condition: job_confirmation_conditions, last_condition: job_termination_condition }
      construct_blocks_for_conditions(job_confirmation_conditions, job_termination_condition)
    end

    def construct_blocks_for_conditions(job_confirmation_conditions, job_termination_condition)
      hash_conditions = {}
      CapistranoMulticonfigParallel.configuration.task_confirmations.each_with_index do |task, index|
        blk = lambda do |sum|
          need_confirmation_for_tasks? ? job_confirmation_conditions[index].signal(sum) : job_confirmation_conditions[index].call(sum)
        end
        hash_conditions[task] = blk
      end
      blk_termination = lambda do |sum|
        job_termination_condition.signal(sum)
      end
      @manager_condition = hash_conditions
      @last_manager_condition = blk_termination
    end

    def crashed?
      @action_name == 'deploy:rollback'
    end

    def notify_finished(exit_status)
      return unless @execute_deploy
      if exit_status.exitstatus != 0
        debug("worker #{job_id} tries to terminate")
        terminate
      else
        update_machine_state('FINISHED')
        debug("worker #{job_id} notifies manager has finished")
        @last_manager_condition.call('yes')
      end
    end
  end
end
